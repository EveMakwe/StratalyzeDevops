name: Deploy to Productiond

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:


    
env:
  NAMESPACE: coffee-queue

jobs:
  deploy-prod:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || contains(github.event.pull_request.labels.*.name, 'deploy-app') || github.event_name == 'workflow_dispatch'
    environment:
      name: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
    
    - name: Set up Kind cluster
      uses: helm/kind-action@v1.8.0
      with:
        cluster_name: coffee-queue-prod-cluster
        wait: 30s
    
    - name: Build Docker image with cache
      run: |
        docker build \
          --cache-from coffee-queue-app:latest \
          --build-arg BUILDKIT_INLINE_CACHE=1 \
          -t coffee-queue-app:latest \
          ./coffeequeue
    
    - name: Load Docker image to Kind
      run: |
        kind load docker-image coffee-queue-app:latest --name coffee-queue-prod-cluster
    
    - name: Create production namespace
      run: |
        kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
        kubectl label namespace ${{ env.NAMESPACE }} environment=production --overwrite
    
    - name: Create PostgreSQL secrets
      env:
        POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
        POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
        POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      run: |
        kubectl create secret generic postgres-secret \
          --from-literal=POSTGRES_DB="$POSTGRES_DB" \
          --from-literal=POSTGRES_USER="$POSTGRES_USER" \
          --from-literal=POSTGRES_PASSWORD="$POSTGRES_PASSWORD" \
          -n ${{ env.NAMESPACE }} \
          --dry-run=client -o yaml | kubectl apply -f -
    
    - name: Deploy PostgreSQL
      run: |
        kubectl apply -f k8s/postgres/ -n ${{ env.NAMESPACE }}
        echo "PostgreSQL resources applied"
    
    - name: Wait for PostgreSQL with retries
      run: |
        set +e
        RETRIES=0
        MAX_RETRIES=3
        
        while [ $RETRIES -lt $MAX_RETRIES ]; do
          echo "Attempt $((RETRIES + 1))/$MAX_RETRIES: Waiting for PostgreSQL..."
          
          if kubectl wait --for=condition=available --timeout=120s deployment/postgres -n ${{ env.NAMESPACE }}; then
            echo "PostgreSQL is ready!"
            exit 0
          fi
          
          echo "PostgreSQL not ready yet. Checking status..."
          kubectl get pods -l app=postgres -n ${{ env.NAMESPACE }}
          kubectl describe pod -l app=postgres -n ${{ env.NAMESPACE }} | tail -30
          kubectl logs -l app=postgres -n ${{ env.NAMESPACE }} --tail=30 || true
          
          RETRIES=$((RETRIES + 1))
          if [ $RETRIES -lt $MAX_RETRIES ]; then
            echo "Retrying in 10 seconds..."
            sleep 10
          fi
        done
        
        echo "PostgreSQL failed to become ready after $MAX_RETRIES attempts"
        exit 1
    
    - name: Create application secrets
      env:
        POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
        POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
        POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      run: |
        kubectl create secret generic app-secret \
          --from-literal=SPRING_DATASOURCE_URL="jdbc:postgresql://postgres-service:5432/$POSTGRES_DB" \
          --from-literal=SPRING_DATASOURCE_USERNAME="$POSTGRES_USER" \
          --from-literal=SPRING_DATASOURCE_PASSWORD="$POSTGRES_PASSWORD" \
          -n ${{ env.NAMESPACE }} \
          --dry-run=client -o yaml | kubectl apply -f -
    
    - name: Deploy Application
      run: |
        kubectl apply -f k8s/app/deployment.yaml -n ${{ env.NAMESPACE }}
        kubectl apply -f k8s/app/service.yaml -n ${{ env.NAMESPACE }}
        kubectl apply -f k8s/app/hpa.yaml -n ${{ env.NAMESPACE }}
        echo "Application resources applied"
    
    - name: Wait for Application with retries
      run: |
        set +e
        RETRIES=0
        MAX_RETRIES=3
        
        while [ $RETRIES -lt $MAX_RETRIES ]; do
          echo "Attempt $((RETRIES + 1))/$MAX_RETRIES: Waiting for Application..."
          
          kubectl get pods -l app=coffee-queue-app -n ${{ env.NAMESPACE }}
          
          if kubectl wait --for=condition=available --timeout=120s deployment/coffee-queue-app -n ${{ env.NAMESPACE }}; then
            echo "Application is ready!"
            exit 0
          fi
          
          echo "Application not ready yet. Diagnosing..."
          kubectl describe pod -l app=coffee-queue-app -n ${{ env.NAMESPACE }} | grep -A 20 "Events:" || true
          
          for pod in $(kubectl get pods -l app=coffee-queue-app -n ${{ env.NAMESPACE }} -o name); do
            echo "--- Logs from $pod (init container) ---"
            kubectl logs $pod -c wait-for-postgres -n ${{ env.NAMESPACE }} --tail=20 || true
            echo "--- Logs from $pod (main container) ---"
            kubectl logs $pod -c coffee-queue-app -n ${{ env.NAMESPACE }} --tail=50 || true
          done
          
          RETRIES=$((RETRIES + 1))
          if [ $RETRIES -lt $MAX_RETRIES ]; then
            echo "Retrying in 15 seconds..."
            sleep 15
          fi
        done
        
        echo "Application failed to become ready after $MAX_RETRIES attempts"
        exit 1
    
    - name: Run smoke tests
      timeout-minutes: 2
      run: |
        kubectl port-forward service/coffee-queue-service 8080:8080 -n ${{ env.NAMESPACE }} &
        PORT_FORWARD_PID=$!
        sleep 10
        curl -f http://localhost:8080/health || exit 1
        curl -f -X POST "http://localhost:8080/order?name=TestUser" || exit 1
        kill $PORT_FORWARD_PID 2>/dev/null || true
        echo "All tests passed"
    
    - name: Show deployment info
      if: success()
      run: |
        echo "Production deployment successful!"
        echo "Namespace: ${{ env.NAMESPACE }}"
        echo "Access: kubectl port-forward service/coffee-queue-service 8080:8080 -n ${{ env.NAMESPACE }}"
